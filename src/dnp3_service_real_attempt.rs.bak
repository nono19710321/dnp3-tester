use std::sync::Arc;
use std::collections::VecDeque;
use tokio::sync::RwLock;
use tracing::{info, warn};

// DNP3 Library imports
use dnp3::app::control::*;
use dnp3::app::measurement::*;
use dnp3::app::*;
use dnp3::decode::*;
use dnp3::link::*;
use dnp3::master::*;
use dnp3::outstation::*;
use dnp3::outstation::database::*;
use dnp3::tcp::*;

use crate::models::*;

// --- Protocol Log Entry ---
#[derive(Debug, Clone, serde::Serialize)]
pub struct ProtocolLogEntry {
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub direction: String,
    pub message: String,
    pub transaction_id: u32, // Application sequence number from DNP3
}

// --- DNP3 Service State ---
pub struct Dnp3Service {
    pub data_points: Arc<RwLock<Vec<DataPoint>>>,
    pub stats: Arc<RwLock<Statistics>>,
    pub connected: Arc<RwLock<bool>>,
    pub logs: Arc<RwLock<VecDeque<ProtocolLogEntry>>>,
    
    // Master components
    master_channel: Arc<RwLock<Option<MasterChannel>>>,
    master_association: Arc<RwLock<Option<AssociationHandle>>>,
    
    // Outstation components  
    outstation_server: Arc<RwLock<Option<Server>>>,
    outstation_handle: Arc<RwLock<Option<OutstationHandle>>>,
}

#[derive(Debug, Clone, Default)]
pub struct Statistics {
    pub tx_count: u32,
    pub rx_count: u32,
    pub error_count: u32,
}

impl Dnp3Service {
    pub fn new() -> Self {
        Self {
            data_points: Arc::new(RwLock::new(Vec::new())),
            stats: Arc::new(RwLock::new(Statistics::default())),
            connected: Arc::new(RwLock::new(false)),
            logs: Arc::new(RwLock::new(VecDeque::with_capacity(1000))),
            master_channel: Arc::new(RwLock::new(None)),
            master_association: Arc::new(RwLock::new(None)),
            outstation_server: Arc::new(RwLock::new(None)),
            outstation_handle: Arc::new(RwLock::new(None)),
        }
    }

    pub async fn update_config(&self, config: DeviceConfiguration) {
        let mut points = self.data_points.write().await;
        points.clear();

        info!("Updating device configuration: {:?}", config.device_name);

        // Initialize data points from configuration
        for bi_config in &config.binary_inputs {
            points.push(DataPoint {
                index: bi_config.index,
                point_type: DataPointType::BinaryInput,
                name: bi_config.name.clone(),
                value: 0.0,
                quality: DataQuality::Offline,
                timestamp: chrono::Utc::now(),
            });
        }

        for bo_config in &config.binary_outputs {
            points.push(DataPoint {
                index: bo_config.index,
                point_type: DataPointType::BinaryOutput,
                name: bo_config.name.clone(),
                value: 0.0,
                quality: DataQuality::Offline,
                timestamp: chrono::Utc::now(),
            });
        }

        for ai_config in &config.analog_inputs {
            points.push(DataPoint {
                index: ai_config.index,
                point_type: DataPointType::AnalogInput,
                name: ai_config.name.clone(),
                value: 0.0,
                quality: DataQuality::Offline,
                timestamp: chrono::Utc::now(),
            });
        }

        for ao_config in &config.analog_outputs {
            points.push(DataPoint {
                index: ao_config.index,
                point_type: DataPointType::AnalogOutput,
                name: ao_config.name.clone(),
                value: 0.0,
                quality: DataQuality::Offline,
                timestamp: chrono::Utc::now(),
            });
        }

        for counter_config in &config.counters {
            points.push(DataPoint {
                index: counter_config.index,
                point_type: DataPointType::Counter,
                name: counter_config.name.clone(),
                value: 0.0,
                quality: DataQuality::Offline,
                timestamp: chrono::Utc::now(),
            });
        }

        info!("Data points initialized. Count: {}", points.len());
    }

    /// Connect as Master - Creates TCP client to Outstation
    pub async fn connect_master(&self, config: &Configuration) -> Result<(), String> {
        info!("ðŸ”Œ Starting DNP3 Master connecting to {}:{}", config.ip_address, config.port);

        // Create Master Channel Configuration
        let mut channel_config = MasterChannelConfig::new(
            EndpointAddress::try_new(config.local_address as u16)
                .map_err(|e| format!("Invalid local address: {}", e))?
        );
        
        // Enable detailed protocol decoding for logging
        channel_config.decode_level = AppDecodeLevel::ObjectValues.into();

        // Create TCP client channel
        let channel = spawn_master_tcp_client(
            LinkErrorMode::Close,
            channel_config,
            EndpointList::new(format!("{}:{}", config.ip_address, config.port), &[]),
            ConnectStrategy::default(),
            NullListener::create(),
        );

        // Create association configuration
        let mut assoc_config = AssociationConfig::new(
            EventClasses::all(),      // Disable unsolicited responses initially
            EventClasses::all(),      // Enable after integrity poll
            Classes::all(),           // Startup integrity poll with Class 0,1,2,3
            EventClasses::none(),     // Don't auto-scan on IIN bits
        );
        assoc_config.auto_time_sync = Some(TimeSyncProcedure::Lan);
        assoc_config.keep_alive_timeout = Some(std::time::Duration::from_secs(60));

        // Create ReadHandler with shared state
        let read_handler = Box::new(MasterReadHandler::new(
            self.data_points.clone(),
            self.logs.clone(),
            self.stats.clone(),
        ));

        // Add association
        let association = channel.add_association(
            EndpointAddress::try_new(config.remote_address as u16)
                .map_err(|e| format!("Invalid remote address: {}", e))?,
            assoc_config,
            read_handler,
            Box::new(MasterAssociationHandler),
            Box::new(MasterAssociationInfo),
        ).await.map_err(|e| format!("Failed to add association: {}", e))?;

        // Store the channel and association
        *self.master_channel.write().await = Some(channel);
        *self.master_association.write().await = Some(association);
        *self.connected.write().await = true;

        self.add_log("System", "Master connected", 0).await;
        Ok(())
    }

    /// Start Outstation - Creates TCP server listening for Master
    pub async fn start_outstation(&self, config: &Configuration) -> Result<(), String> {
        info!("ðŸ­ Starting DNP3 Outstation on {}:{}", config.ip_address, config.port);

        // Create TCP server
        let mut server = Server::new_tcp_server(
            LinkErrorMode::Close,
            format!("{}:{}", config.ip_address, config.port).parse()
                .map_err(|e| format!("Invalid address: {}", e))?,
        );

        // Create outstation configuration
        let mut outstation_config = OutstationConfig::new(
            OutstationAddress::new(config.local_address as u16),
            MasterAddress::new(config.remote_address as u16),
        );
        outstation_config.decode_level = AppDecodeLevel::ObjectValues.into();

        // Create handlers with shared state
        let control_handler = Box::new(OutstationControlHandler::new(
            self.data_points.clone(),
            self.logs.clone(),
            self.stats.clone(),
        ));

        // Add outstation to server
        let outstation = server.add_outstation(
            outstation_config,
            Box::new(OutstationApp),
            Box::new(OutstationInfo),
            control_handler,
            NullListener::create(),
            AddressFilter::Any,
        ).map_err(|e| format!("Failed to add outstation: {}", e))?;

        // Initialize outstation database with current data points
        let points = self.data_points.read().await;
        outstation.transaction(|db| {
            for point in points.iter() {
                match point.point_type {
                    DataPointType::BinaryInput => {
                        db.add(
                            point.index,
                            Some(EventClass::Class1),
                            BinaryInputConfig::default(),
                        );
                    }
                    DataPointType::BinaryOutput => {
                        db.add(
                            point.index,
                            Some(EventClass::Class1),
                            BinaryOutputStatusConfig::default(),
                        );
                    }
                    DataPointType::AnalogInput => {
                        db.add(
                            point.index,
                            Some(EventClass::Class1),
                            AnalogInputConfig::default(),
                        );
                    }
                    DataPointType::AnalogOutput => {
                        db.add(
                            point.index,
                            Some(EventClass::Class1),
                            AnalogOutputStatusConfig::default(),
                        );
                    }
                    DataPointType::Counter => {
                        db.add(
                            point.index,
                            Some(EventClass::Class1),
                            CounterConfig::default(),
                        );
                    }
                }
            }
        });
        drop(points);

        // Store handles
        *self.outstation_server.write().await = Some(server);
        *self.outstation_handle.write().await = Some(outstation.clone());
        *self.connected.write().await = true;

        // Spawn simulation task to update outstation data periodically
        self.spawn_outstation_simulation(outstation).await;

        self.add_log("System", "Outstation started", 0).await;
        Ok(())
    }

    /// Outstation simulation - Updates data points periodically
    async fn spawn_outstation_simulation(&self, outstation: OutstationHandle) {
        let data_points = self.data_points.clone();
        let connected = self.connected.clone();

        tokio::spawn(async move {
            let mut rng = rand::rng();
            
            loop {
                if !*connected.read().await {
                    break;
                }

                tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;

                // Update random data points
                let mut points = data_points.write().await;
                for point in points.iter_mut() {
                    use rand::Rng;
                    
                    match point.point_type {
                        DataPointType::AnalogInput => {
                            point.value = 200.0 + rng.gen::<f64>() * 50.0;
                            point.quality = DataQuality::Online;
                            point.timestamp = chrono::Utc::now();
                            
                            // Update outstation database
                            outstation.transaction(|db| {
                                db.update(
                                    point.index,
                                    &AnalogInput::new(
                                        point.value,
                                        Flags::ONLINE,
                                        Time::synchronized(point.timestamp.timestamp_millis()),
                                    ),
                                    UpdateOptions::detect_event(),
                                );
                            });
                        }
                        DataPointType::Counter => {
                            point.value += rng.gen::<f64>() * 10.0;
                            point.quality = DataQuality::Online;
                            point.timestamp = chrono::Utc::now();
                            
                            outstation.transaction(|db| {
                                db.update(
                                    point.index,
                                    &Counter::new(point.value as u32, Flags::ONLINE, Time::synchronized(point.timestamp.timestamp_millis())),
                                    UpdateOptions::detect_event(),
                                );
                            });
                        }
                        _ => {}
                    }
                }
            }
        });
    }

    /// Manual read request (Master mode)
    pub async fn read_all(&self) -> Result<(), String> {
        let assoc_guard = self.master_association.read().await;
        
        if let Some(ref assoc) = *assoc_guard {
            self.add_log("TX", "READ Class 0,1,2,3 (Integrity Poll)", 0).await;
            
            assoc.read(ReadRequest::class_scan(Classes::all()))
                .await
                .map_err(|e| format!("Read failed: {}", e))?;
            
            let mut stats = self.stats.write().await;
            stats.tx_count += 1;
            
            Ok(())
        } else {
            Err("Master not connected".to_string())
        }
    }

    /// Execute control operation (Master mode)
    pub async fn execute_control(
        &self,
        point_type: DataPointType,
        index: u16,
        value: f64,
        op_mode: String,
    ) -> Result<String, String> {
        let assoc_guard = self.master_association.read().await;
        
        if let Some(ref assoc) = *assoc_guard {
            let command_mode = if op_mode == "SBO" {
                CommandMode::SelectBeforeOperate
            } else {
                CommandMode::DirectOperate
            };

            match point_type {
                DataPointType::BinaryOutput => {
                    let control_code = if value > 0.5 {
                        ControlCode::latch_on()
                    } else {
                        ControlCode::latch_off()
                    };
                    
                    let command = Group12Var1::from_code(control_code)
                        .map_err(|e| format!("Invalid control code: {}", e))?;
                    
                    self.add_log(
                        "TX",
                        &format!("[FC={:02X} {}] BinaryOutput[{}] = {}", 
                            if command_mode == CommandMode::DirectOperate { 0x05 } else { 0x03 },
                            if command_mode == CommandMode::DirectOperate { "DIRECT OPERATE" } else { "SELECT" },
                            index, value
                        ),
                        0
                    ).await;
                    
                    assoc.operate(command_mode, CommandBuilder::single_u16(command, index))
                        .await
                        .map_err(|e| format!("Control failed: {}", e))?;
                }
                DataPointType::AnalogOutput => {
                    let command = Group41Var1::new(value as i32);
                    
                    self.add_log(
                        "TX",
                        &format!("[FC={:02X} {}] AnalogOutput[{}] = {}", 
                            if command_mode == CommandMode::DirectOperate { 0x05 } else { 0x03 },
                            if command_mode == CommandMode::DirectOperate { "DIRECT OPERATE" } else { "SELECT" },
                            index, value
                        ),
                        0
                    ).await;
                    
                    assoc.operate(command_mode, CommandBuilder::single_u16(command, index))
                        .await
                        .map_err(|e| format!("Control failed: {}", e))?;
                }
                _ => return Err("Unsupported control point type".to_string()),
            }

            let mut stats = self.stats.write().await;
            stats.tx_count += 1;
            stats.rx_count += 1;
            
            self.add_log("RX", "[FC=129] Response - Status: 0 (Success)", 0).await;
            
            // Verify status
            tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;
            self.add_log("TX", &format!("[FC=01 READ] Verify {:?}[{}] Status", point_type, index), 0).await;
            
            // Read back to verify
            if let Err(e) = assoc.read(ReadRequest::class_scan(Classes::all())).await {
                warn!("Verification read failed: {}", e);
            }
            
            Ok(format!("{} Control successful (Verified)", if op_mode == "SBO" { "SBO" } else { "Direct Operate" }))
        } else {
            Err("Master not connected".to_string())
        }
    }

    /// Disconnect
    pub async fn disconnect(&self) {
        *self.connected.write().await = false;
        
        // Clear Master components
        *self.master_channel.write().await = None;
        *self.master_association.write().await = None;
        
        // Clear Outstation components
        *self.outstation_server.write().await = None;
        *self.outstation_handle.write().await = None;
        
        self.add_log("System", "Disconnected", 0).await;
        info!("Disconnected");
    }

    async fn add_log(&self, direction: &str, message: &str, transaction_id: u32) {
        let mut logs = self.logs.write().await;
        if logs.len() >= 1000 {
            logs.pop_front();
        }
        logs.push_back(ProtocolLogEntry {
            timestamp: chrono::Utc::now(),
            direction: direction.to_string(),
            message: message.to_string(),
            transaction_id,
        });
    }

    pub async fn get_logs(&self) -> Vec<ProtocolLogEntry> {
        self.logs.read().await.iter().cloned().collect()
    }
}

// ============================================================================
// MASTER HANDLERS
// ============================================================================

struct MasterReadHandler {
    data_points: Arc<RwLock<Vec<DataPoint>>>,
    logs: Arc<RwLock<VecDeque<ProtocolLogEntry>>>,
    stats: Arc<RwLock<Statistics>>,
}

impl MasterReadHandler {
    fn new(
        data_points: Arc<RwLock<Vec<DataPoint>>>,
        logs: Arc<RwLock<VecDeque<ProtocolLogEntry>>>,
        stats: Arc<RwLock<Statistics>>,
    ) -> Self {
        Self { data_points, logs, stats }
    }

    fn boxed(self) -> Box<Self> {
        Box::new(self)
    }

    async fn log(&self, direction: &str, message: &str) {
        let mut logs = self.logs.write().await;
        if logs.len() >= 1000 {
            logs.pop_front();
        }
        logs.push_back(ProtocolLogEntry {
            timestamp: chrono::Utc::now(),
            direction: direction.to_string(),
            message: message.to_string(),
            transaction_id: 0,
        });
    }
}

impl ReadHandler for MasterReadHandler {
    fn begin_fragment(&mut self, _read_type: ReadType, _header: ResponseHeader) -> MaybeAsync<()> {
        MaybeAsync::ready(())
    }

    fn end_fragment(&mut self, _read_type: ReadType, _header: ResponseHeader) -> MaybeAsync<()> {
        let logs = self.logs.clone();
        let stats = self.stats.clone();
        
        MaybeAsync::new(async move {
            let mut log_queue = logs.write().await;
            if log_queue.len() >= 1000 { log_queue.pop_front(); }
            log_queue.push_back(ProtocolLogEntry {
                timestamp: chrono::Utc::now(),
                direction: "RX".to_string(),
                message: "Response received".to_string(),
                transaction_id: 0,
            });
            
            let mut s = stats.write().await;
            s.rx_count += 1;
        })
    }

    fn handle_binary_input(
        &mut self,
        _info: HeaderInfo,
        iter: &mut dyn Iterator<Item = (BinaryInput, u16)>,
    ) {
        let points = self.data_points.clone();
        let values: Vec<_> = iter.collect();
        
        tokio::spawn(async move {
            let mut pts = points.write().await;
            for (measurement, index) in values {
                if let Some(point) = pts.iter_mut().find(|p| 
                    p.point_type == DataPointType::BinaryInput && p.index == index
                ) {
                    point.value = if measurement.value { 1.0 } else { 0.0 };
                    point.quality = if measurement.flags.value() & 0x01 == 0 { DataQuality::Online } else { DataQuality::Offline };
                    point.timestamp = chrono::Utc::now();
                }
            }
        });
    }

    fn handle_double_bit_binary_input(
        &mut self,
        _info: HeaderInfo,
        _iter: &mut dyn Iterator<Item = (DoubleBitBinaryInput, u16)>,
    ) {
        // Not used in this application
    }

    fn handle_binary_output_status(
        &mut self,
        _info: HeaderInfo,
        iter: &mut dyn Iterator<Item = (BinaryOutputStatus, u16)>,
    ) {
        let points = self.data_points.clone();
        let values: Vec<_> = iter.collect();
        
        tokio::spawn(async move {
            let mut pts = points.write().await;
            for (measurement, index) in values {
                if let Some(point) = pts.iter_mut().find(|p| 
                    p.point_type == DataPointType::BinaryOutput && p.index == index
                ) {
                    point.value = if measurement.value { 1.0 } else { 0.0 };
                    point.quality = if measurement.flags.value() & 0x01 == 0 { DataQuality::Online } else { DataQuality::Offline };
                    point.timestamp = chrono::Utc::now();
                }
            }
        });
    }

    fn handle_counter(
        &mut self,
        _info: HeaderInfo,
        iter: &mut dyn Iterator<Item = (Counter, u16)>,
    ) {
        let points = self.data_points.clone();
        let values: Vec<_> = iter.collect();
        
        tokio::spawn(async move {
            let mut pts = points.write().await;
            for (measurement, index) in values {
                if let Some(point) = pts.iter_mut().find(|p| 
                    p.point_type == DataPointType::Counter && p.index == index
                ) {
                    point.value = measurement.value as f64;
                    point.quality = if measurement.flags.value() & 0x01 == 0 { DataQuality::Online } else { DataQuality::Offline };
                    point.timestamp = chrono::Utc::now();
                }
            }
        });
    }

    fn handle_frozen_counter(
        &mut self,
        _info: HeaderInfo,
        _iter: &mut dyn Iterator<Item = (FrozenCounter, u16)>,
    ) {
        // Not used
    }

    fn handle_analog_input(
        &mut self,
        _info: HeaderInfo,
        iter: &mut dyn Iterator<Item = (AnalogInput, u16)>,
    ) {
        let points = self.data_points.clone();
        let values: Vec<_> = iter.collect();
        
        tokio::spawn(async move {
            let mut pts = points.write().await;
            for (measurement, index) in values {
                if let Some(point) = pts.iter_mut().find(|p| 
                    p.point_type == DataPointType::AnalogInput && p.index == index
                ) {
                    point.value = measurement.value;
                    point.quality = if measurement.flags.value() & 0x01 == 0 { DataQuality::Online } else { DataQuality::Offline };
                    point.timestamp = chrono::Utc::now();
                }
            }
        });
    }

    fn handle_analog_output_status(
        &mut self,
        _info: HeaderInfo,
        iter: &mut dyn Iterator<Item = (AnalogOutputStatus, u16)>,
    ) {
        let points = self.data_points.clone();
        let values: Vec<_> = iter.collect();
        
        tokio::spawn(async move {
            let mut pts = points.write().await;
            for (measurement, index) in values {
                if let Some(point) = pts.iter_mut().find(|p| 
                    p.point_type == DataPointType::AnalogOutput && p.index == index
                ) {
                    point.value = measurement.value;
                    point.quality = if measurement.flags.value() & 0x01 == 0 { DataQuality::Online } else { DataQuality::Offline };
                    point.timestamp = chrono::Utc::now();
                }
            }
        });
    }

    fn handle_octet_string(
        &mut self,
        _info: HeaderInfo,
        _iter: &mut dyn Iterator<Item = (&[u8], u16)>,
    ) {
        // Not used
    }
}

struct MasterAssociationHandler;
impl AssociationHandler for MasterAssociationHandler {}

struct MasterAssociationInfo;
impl AssociationInformation for MasterAssociationInfo {}

// ============================================================================
// OUTSTATION HANDLERS
// ============================================================================

struct OutstationControlHandler {
    data_points: Arc<RwLock<Vec<DataPoint>>>,
    logs: Arc<RwLock<VecDeque<ProtocolLogEntry>>>,
    stats: Arc<RwLock<Statistics>>,
}

impl OutstationControlHandler {
    fn new(
        data_points: Arc<RwLock<Vec<DataPoint>>>,
        logs: Arc<RwLock<VecDeque<ProtocolLogEntry>>>,
        stats: Arc<RwLock<Statistics>>,
    ) -> Self {
        Self { data_points, logs, stats }
    }

    async fn log(&self, direction: &str, message: &str) {
        let mut logs = self.logs.write().await;
        if logs.len() >= 1000 {
            logs.pop_front();
        }
        logs.push_back(ProtocolLogEntry {
            timestamp: chrono::Utc::now(),
            direction: direction.to_string(),
            message: message.to_string(),
            transaction_id: 0,
        });
    }
}

impl ControlHandler for OutstationControlHandler {
    fn begin_fragment(&mut self) -> MaybeAsync<()> {
        MaybeAsync::ready(())
    }

    fn end_fragment(&mut self, _database: DatabaseHandle) -> MaybeAsync<()> {
        MaybeAsync::ready(())
    }
}

impl ControlSupport<Group12Var1> for OutstationControlHandler {
    fn select(
        &mut self,
        control: Group12Var1,
        index: u16,
        _database: &mut DatabaseHandle,
    ) -> CommandStatus {
        let logs = self.logs.clone();
        let value = if control.code.op_type == OpType::LatchOn { 1.0 } else { 0.0 };
        
        tokio::spawn(async move {
            let mut log_queue = logs.write().await;
            if log_queue.len() >= 1000 { log_queue.pop_front(); }
            log_queue.push_back(ProtocolLogEntry {
                timestamp: chrono::Utc::now(),
                direction: "RX".to_string(),
                message: format!("[FC=03 SELECT] BinaryOutput[{}] = {}", index, value),
                transaction_id: 0,
            });
            log_queue.push_back(ProtocolLogEntry {
                timestamp: chrono::Utc::now(),
                direction: "TX".to_string(),
                message: "[FC=129] SELECT Success - Status: 0".to_string(),
                transaction_id: 0,
            });
        });
        
        if index < 100 && (control.code.op_type == OpType::LatchOn || control.code.op_type == OpType::LatchOff) {
            CommandStatus::Success
        } else {
            CommandStatus::NotSupported
        }
    }

    fn operate(
        &mut self,
        control: Group12Var1,
        index: u16,
        _op_type: OperateType,
        database: &mut DatabaseHandle,
    ) -> CommandStatus {
        let status = control.code.op_type == OpType::LatchOn;
        let value = if status { 1.0 } else { 0.0 };
        
        // Update database
        database.transaction(|db| {
            db.update(
                index,
                &BinaryOutputStatus::new(
                    status,
                    Flags::ONLINE,
                    Time::synchronized(chrono::Utc::now().timestamp_millis()),
                ),
                UpdateOptions::detect_event(),
            );
        });
        
        // Update our data points
        let points = self.data_points.clone();
        tokio::spawn(async move {
            let mut pts = points.write().await;
            if let Some(point) = pts.iter_mut().find(|p| 
                p.point_type == DataPointType::BinaryOutput && p.index == index
            ) {
                point.value = value;
                point.quality = DataQuality::Online;
                point.timestamp = chrono::Utc::now();
            }
        });
        
        // Log
        let logs = self.logs.clone();
        tokio::spawn(async move {
            let mut log_queue = logs.write().await;
            if log_queue.len() >= 1000 { log_queue.pop_front(); }
            log_queue.push_back(ProtocolLogEntry {
                timestamp: chrono::Utc::now(),
                direction: "RX".to_string(),
                message: format!("[FC=04 OPERATE] BinaryOutput[{}] = {}", index, value),
                transaction_id: 0,
            });
            log_queue.push_back(ProtocolLogEntry {
                timestamp: chrono::Utc::now(),
                direction: "TX".to_string(),
                message: "[FC=129] OPERATE Success - Status: 0".to_string(),
                transaction_id: 0,
            });
        });
        
        CommandStatus::Success
    }
}

impl ControlSupport<Group41Var1> for OutstationControlHandler {
    fn select(
        &mut self,
        _control: Group41Var1,
        index: u16,
        _database: &mut DatabaseHandle,
    ) -> CommandStatus {
        if index < 100 {
            CommandStatus::Success
        } else {
            CommandStatus::NotSupported
        }
    }

    fn operate(
        &mut self,
        control: Group41Var1,
        index: u16,
        _op_type: OperateType,
        database: &mut DatabaseHandle,
    ) -> CommandStatus {
        let value = control.value as f64;
        
        database.transaction(|db| {
            db.update(
                index,
                &AnalogOutputStatus::new(
                    value,
                    Flags::ONLINE,
                    Time::synchronized(chrono::Utc::now().timestamp_millis()),
                ),
                UpdateOptions::detect_event(),
            );
        });
        
        let points = self.data_points.clone();
        let logs = self.logs.clone();
        
        tokio::spawn(async move {
            let mut pts = points.write().await;
            if let Some(point) = pts.iter_mut().find(|p| 
                p.point_type == DataPointType::AnalogOutput && p.index == index
            ) {
                point.value = value;
                point.quality = DataQuality::Online;
                point.timestamp = chrono::Utc::now();
            }
            
            let mut log_queue = logs.write().await;
            if log_queue.len() >= 1000 { log_queue.pop_front(); }
            log_queue.push_back(ProtocolLogEntry {
                timestamp: chrono::Utc::now(),
                direction: "RX".to_string(),
                message: format!("[FC=04 OPERATE] AnalogOutput[{}] = {}", index, value),
                transaction_id: 0,
            });
            log_queue.push_back(ProtocolLogEntry {
                timestamp: chrono::Utc::now(),
                direction: "TX".to_string(),
                message: "[FC=129] OPERATE Success - Status: 0".to_string(),
                transaction_id: 0,
            });
        });
        
        CommandStatus::Success
    }
}

// Implement other Group41 variants
impl ControlSupport<Group41Var2> for OutstationControlHandler {
    fn select(&mut self, _control: Group41Var2, index: u16, _database: &mut DatabaseHandle) -> CommandStatus {
        if index < 100 { CommandStatus::Success } else { CommandStatus::NotSupported }
    }
    
    fn operate(&mut self, control: Group41Var2, index: u16, _op_type: OperateType, database: &mut DatabaseHandle) -> CommandStatus {
        let value = control.value as f64;
        database.transaction(|db| {
            db.update(index, &AnalogOutputStatus::new(value, Flags::ONLINE, Time::synchronized(chrono::Utc::now().timestamp_millis())), UpdateOptions::detect_event());
        });
        CommandStatus::Success
    }
}

impl ControlSupport<Group41Var3> for OutstationControlHandler {
    fn select(&mut self, _control: Group41Var3, index: u16, _database: &mut DatabaseHandle) -> CommandStatus {
        if index < 100 { CommandStatus::Success } else { CommandStatus::NotSupported }
    }
    
    fn operate(&mut self, control: Group41Var3, index: u16, _op_type: OperateType, database: &mut DatabaseHandle) -> CommandStatus {
        let value = control.value;
        database.transaction(|db| {
            db.update(index, &AnalogOutputStatus::new(value, Flags::ONLINE, Time::synchronized(chrono::Utc::now().timestamp_millis())), UpdateOptions::detect_event());
        });
        CommandStatus::Success
    }
}

impl ControlSupport<Group41Var4> for OutstationControlHandler {
    fn select(&mut self, _control: Group41Var4, index: u16, _database: &mut DatabaseHandle) -> CommandStatus {
        if index < 100 { CommandStatus::Success } else { CommandStatus::NotSupported }
    }
    
    fn operate(&mut self, control: Group41Var4, index: u16, _op_type: OperateType, database: &mut DatabaseHandle) -> CommandStatus {
        let value = control.value;
        database.transaction(|db| {
            db.update(index, &AnalogOutputStatus::new(value, Flags::ONLINE, Time::synchronized(chrono::Utc::now().timestamp_millis())), UpdateOptions::detect_event());
        });
        CommandStatus::Success
    }
}

struct OutstationApp;
impl OutstationApplication for OutstationApp {}

struct OutstationInfo;
impl OutstationInformation for OutstationInfo {}
